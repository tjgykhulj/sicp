(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;53
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;54
(define (equal? a b)
  (if (and (pair? a) (pair? b))
      (and (equal? (car a) (car b))
           (equal? (cdr a) (cdr b)))
      (eq? a b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (variable? x) (symbol? x))
(define (=number? x val) (and (number? x) (= x val)))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (make-product a1 a2)
  (cond ((or (=number? a1 0) (=number? a2 0)) 0)
        ((=number? a1 1) a2)
        ((=number? a2 1) a1)
        ((and (number? a1) (number? a2)) (* a1 a2))
        (else (list '* a1 a2))))
(define (sum? x)
  (and (pair? x) (eq? (opt x) '+)))
(define (product? x)
  (and (pair? x) (eq? (opt x) '*)))

(define (opt s) (car s))
(define (arg1 s) (cadr s))
(define (arg2 s)
  (let ((ans (cddr s)))
    (if (null? (cdr ans))
        (car ans)
        (cons (car s) ans))))
             
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (arg1 exp) var)
                   (deriv (arg2 exp) var)))
        ((product? exp)
         (make-sum
          (make-product (arg1 exp)
                        (deriv (arg2 exp) var))
          (make-product (deriv (arg1 exp) var)
                        (arg2 exp))))
        ((exponentiation? exp)
         (let ((base (arg1 exp))
               (e (arg2 exp)))
           (make-product
            (make-product e
             (make-exponentiation base (- e 1)))
            (deriv base var))))
        (else
         (error "unknown expression type -- DERIV" exp))))

(deriv '(+ x 3) 'x)
(deriv '(* x y) 'x)
(deriv '(* (* x y) (+ x 3)) 'x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;56
(define (exponentiation? x)
  (and (pair? x) (eq? (opt x) '**)))
(define (make-exponentiation base e)
  (cond ((=number? e 0) 1)
        ((or (=number? base 0) (=number? e 1)
             (=number? base 1)) base)
        (else (list '** base e))))

(deriv '(** x 3) 'x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;57
(deriv '(+ x y (* x x)) 'x)
(deriv '(* x y (+ x 3)) 'x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;58
(define (arg1 x) (car x))
(define (arg2 x) (caddr x))
(define (opt x) (cadr x))
(define (make-exponentiation base e)
  (cond ((=number? e 0) 1)
        ((or (=number? base 0) (=number? e 1)
             (=number? base 1)) base)
        (else (list base '** e))))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+ a2))))
(define (make-product a1 a2)
  (cond ((or (=number? a1 0) (=number? a2 0)) 0)
        ((=number? a1 1) a2)
        ((=number? a2 1) a1)
        ((and (number? a1) (number? a2)) (* a1 a2))
        (else (list a1 '* a2))))
(deriv '(x + (3 * (x + y))) 'x)
(deriv '(x ** 3) 'x)

